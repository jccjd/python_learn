#### python的函数参数传递
 
python的所有变量都可以理解是内存中一个对象的“引用”,类型是属于对象的，而不是变量。对象有两种，“可更改与不可更改。在python中，string,tuples,和numbers是不可更改的对象，而list，dict，set等则是可以修改的对象。
#### python的标准数据类型
    numbers(int long float complex)
    string
    List
    Tuple
    Dictionary
##### string
   重点是对string的切片
    
    从左到右0 - n：0,1,2,3....
    从右到左-n - -1:-n,...-3,-2, -1
    切片时要头下标和尾下标和步长
##### list
可以存放更多的数据类型，切片方式和string类似

    list = [ 'runoob', 786 , 2.23, 'john', 70.2 ]
    tinylist = [123, 'john']
    print list               # 输出完整列表
    print list[0]            # 输出列表的第一个元素
    print list[1:3]          # 输出第二个至第三个元素 
    print list[2:]           # 输出从第三个开始至列表末尾的所有元素
    print tinylist * 2       # 输出列表两次
    print list + tinylist    # 打印组合的列表
#### python元类（metaclass)
用于orm的单例模式，对数据库对象实现保护，确保全局只有一个数据库对象
metaclass，直译为元类，简单的解释就是：
当我们定义了类以后，就可以根据这个类创建出实例，所以：先定义类，然后创建实例。
但是如果我们想创建出类呢？那就必须根据metaclass创建出类，所以：先定义metaclass，然后创建类。
连接起来就是：先定义metaclass，就可以创建类，最后创建实例。
所以，metaclass允许你创建类或者修改类。换句话说，你可以把类看成是metaclass创建出来的“实例”。
#### @staticmethod，和@classmethod
python有三种方法即静态方法(staticmethod)，类方法(classmethod)和实例方法
    
    def foo(x):
    print("executing foo(%s)"%(1))
    class A(object):
        def foo(self,x):
            print("executing foo(%s,%s)"%(self,x))
        @classmethod
        def class_foo(cls,x):
            print("executing class_foo(%s,%s)"%(cls,x))
        @staticmethod
        def static_foo(x):
            print("executing static_foo(%s)"%x)
            

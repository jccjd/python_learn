### 创建一个线程
创建线程一般用 threading 类来创建线程，thread 模块被废弃，python3中的thread
模块为_thread, 下面的代码可以看到不用等待，直接执行，相当于并行执行了
可以提高速度
    
        import time
        import threading
        def work():
        for i in range(3):
            print("---->",i)
            time.sleep(1)
        
        work()
        t = Thread(target=work)
        t.start()
        
        t2 = Thread(target=work)
        t2.start()
        
        t3 = Thread(target=work)
        t3.start()
        
        t4 = Thread(target=work)
        t4.start()
### 继承实现
可以直接继承threading.Thread继承一个新子类，然后实力花后调用start(),方法
运行run()
    
        from threading import Thread
        import time
        class MyThread(Thread):
            def run(self):
                for i in range(3):
                    time.sleep(1)
                    print(f'name{i}')
            
        def test():
            t = MyThread()
            t.start()
            t2 = MyThread()
            t2.start()
        
        test()
### 同步

对于以上的线程，不对线程加以控制，线程的推进顺序是不可预料的，那么需要对
线程加以控制，使用Thread对象的Lock 和 Rlock 实现简单的线程同步，
多线程的优势是可以同时运行多个任务，当线程需要共享数据时，存在数据不同步
的问题, 加锁后会保证多线程修改不会出错
        
        import threading
        import time
        
         g_num = 0
        
         def test1(num):
            global g_num
            for i in range(num):
                mutex.acquire()  # 上锁
                g_num += 1
                mutex.release()  # 解锁
        
            print("---test1---g_num=%d"%g_num)
         
        # 创建一个互斥锁
        # 默认是未上锁的状态
        mutex = threading.Lock()
        
        # 创建2个线程，让他们各自对g_num加1000000次
        p1 = threading.Thread(target=test1, args=(1000000,))
        p1.start()
        
        p2 = threading.Thread(target=test2, args=(1000000,))
        p2.start()
### 死锁
进程间的不当推进会产生死锁，抢占互斥

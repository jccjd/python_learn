### 正则表达式
`re.match()` 函数 提供了正则式的匹配

参数
- pattern 正则式
- string 要匹配的字符
- flag 是否区分大小写

匹配到返回一个匹配对象，否则返回一个None
- group 匹配的整个表达式的字符串
- 返回匹配位置的前后




    print(re.match('bai','www.baidu.com'))
    line = 'Cats are smarter than dogs'
    matchObj = re.match(r'(.*) are (.*?) .*',line, )
    if matchObj:
        print("matchObj,group()", matchObj.group())
        print("matchObj,group()", matchObj.group(1))
        print("matchObj,group()", matchObj.group(2))

### re.match 和 re.search的区别
re.match只匹配字符串的开始，如果字符串开始不符合正则表达式，则匹配失败，
re.search匹配整个字符串，直到找到一个匹配


### 检索和替换
Python 的 re模块提供了re.sub用于替换字符串的匹配项
- pattern: 正则中的模式字符串
- repl: 替换的字符串 可以是一个函数
- string: 要被查找的源字符串
- conunt: 模式匹配后替换的最大次数，默认为0 全部替换
- flags: 编译时用的匹配模式，数字形式


    phone = '2004-959-559 # 这是一个电话号码'
    # 删除注释
    num = re.sub(r'#.*$', "", phone)
    print("电话号码：", num)
    # 移除非数字的内容
    num = re.sub(r'\D', "", phone)
    print(num)
    
    # 参数是个函数
    def double(mathed):
        value = int(mathed.group('value'))
        return str(value * 2)
    s = 'A23G4H567'
    print(re.sub('(?P<value>\d+)', double,s))

### complile()函数
这个函数用于编译正则表达式，生成一个正则表达式对象，供match()和search()这两个函数使用
    
    # complie(pattern[,flags ,re.I 忽略大小写 re.M多行模式])
    pattern = re.compile(r'\d+') # 匹配至少一个数字
    m = pattern.match('one12twothree34four')
    print(m)

### findall
在字符串中找到正则表达式所匹配的所有的子串，并返回一个列表，若果没有匹配到
则返回一个空列表
match和search是匹配一次findall是匹配所有
- string 待匹配的字符串
- pos 可选的参数，指定字符串的起始位置，默认为0
- endpos可选参数，指定字符串的结束位置，默认为字符串的长度

查找字符串的所有数字
    
    patttern = re.compile(r'\d+') # 查找数字
    result1 = pattern.findall('runoob 123 google 456')
    result2 = pattern.findall('run88oob123google456',0,10)
    print(result1)
    print(result2)


### re.finditer
和findall的效果不过返回的是一个迭代器
### re.split
split方法能够按照匹配的子串将字符串分割后返回列表，

### 正则表达式对象
    
    re.I | 是匹配对大小写不敏感
    re.L | 做本地化识别
    re.M | 多行匹配影响^ $
    re.S | 使 匹配包括换行在内的所有字符
    re.U | 根据Unicode解析字符， 这个标志影响\w, \W,\b \B
    re.X | 该标志通过给予你更灵活的格式以便理解

### 正则表达式模式
    
    ^       |  匹配字符串的开头
    $       |  匹配字符串的末尾
    .       | 匹配任意字符，除了换行符，当re.DoTALL标记被指定时，则可以匹配包括换行符的任意字符
    [.]     | 用来表示一组字符串，单独列出： [amk] 匹配'a',m 或k
    [^..]   | 不在[]中的字符：[^abc]匹配除了a,b,c之外的字符
    re*     | 匹配0个或者多个的表达式
    re+     | 匹配1个或多个的表达式
    re ?    | 匹配0个或1个由前面的正则表达式的片段，非贪婪方式
    re{n}   | 匹配n个前面表达式， 例如， "o{2}"不能匹配“BOb"中的"o",但是能匹配“food"中的两个o
    re{n,m} | 匹配n 到 m次由前面的正则表达式定义的片段
    a|b     | 匹配a 或b
    (re)    | 匹配括号内的表达式
    (?imx)  | 正则表达式包含三种可选标志i,m,x
    (?-img) | 正则表达式关闭i，m，或可选标志
    (?>re)  | 匹配的独立模式
    (\w)    | 匹配数字字母下划线
    (\W)    | 非字母数字下划线
    (\s)    | 匹配任意空白字符
    \S      | 匹配非空白字符
    \d      | 匹配任意字符
    \D      | 匹配任意非数字
    \A      | 字符串匹配开始
    \Z      | 字符串匹配结束
    \G      | 匹配最后完成的位置
    \b      | 匹配一个单词的边界
    \n\t    | 匹配一个换行符，匹配一个制表符
    
    [asdf]  | 匹配中括号中的任意一个字母
    [0-9]   | 匹配任意数字
    [^0-9]  | 匹配非数字
    [a-zA-Z0-9] 匹配任意字母和数字
    
    
    